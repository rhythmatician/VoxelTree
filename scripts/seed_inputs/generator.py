import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import yaml

logger = logging.getLogger(__name__)


@dataclass
class SeedInputGenerator:
    """
    Generate conditioning variables from seed and coordinates using vanilla-accurate tools.

    Biome, heightmap, and river data must come from external generators (e.g., Cubiomes CLI).
    """

    seed: int
    config_path: Optional[Path] = None

    def __post_init__(self):
        """Initialize from seed and configuration."""
        self._load_config()
        self._init_biome_generator()
        logger.info(
            f"SeedInputGenerator initialized with seed={self.seed}, biome_source={self.biome_source}"
        )

    def _load_config(self):
        """Load configuration from YAML file."""
        if self.config_path is None:
            self.config_path = Path(__file__).parent.parent.parent / "config.yaml"

        if self.config_path.exists():
            with open(self.config_path, "r") as f:
                config = yaml.safe_load(f)
                self.config = config.get("seed_inputs", {})
        else:
            logger.warning(f"Config file not found at {self.config_path}, using defaults")
            self.config = {}

        self.biome_source = self.config.get("biome_source", "vanilla")

        vanilla_config = self.config.get("vanilla_biome", {})
        self.java_tool = vanilla_config.get("java_tool", "tools/amidst-cli.jar")
        self.fallback_tool = vanilla_config.get("fallback_tool", "tools/cubeseed.jar")
        self.cache_dir = Path(vanilla_config.get("cache_dir", "data/biome_cache"))
        self.chunk_batch_size = vanilla_config.get("chunk_batch_size", 64)

    def _init_biome_generator(self):
        """Check for vanilla biome tools and raise if missing."""
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.java_tool_path = Path(self.java_tool)
        self.fallback_tool_path = Path(self.fallback_tool)

        if not self.java_tool_path.exists() and not self.fallback_tool_path.exists():
            raise FileNotFoundError(
                f"Neither {self.java_tool_path} nor {self.fallback_tool_path} exist. "
                "Vanilla biome generation requires an external tool."
            )

    def get_biome(self, x: int, z: int) -> int:
        raise NotImplementedError("Biome lookup must be implemented via Cubiomes integration.")

    def get_heightmap(self, x: int, z: int) -> int:
        raise NotImplementedError("Heightmap must be generated by external terrain sampler.")

    def get_river_noise(self, x: int, z: int) -> float:
        raise NotImplementedError("River noise must be generated by external terrain sampler.")

    def get_patch(self, x_start: int, z_start: int, size: int) -> Dict[str, Any]:
        raise NotImplementedError("Patch generation requires biome and heightmap support.")

    def save_patch_npz(self, patch: Dict[str, Any], output_path: Path) -> Path:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        np.savez_compressed(output_path, **patch)
        logger.debug(f"Saved patch to {output_path}")
        return output_path

    def get_patch_filename(self, x: int, z: int, output_dir: Path) -> Path:
        filename = f"patch_x{x}_z{z}.npz"
        return output_dir / filename

    def generate_batch(self, coordinates: List[Tuple[int, int]], size: int) -> List[Dict[str, Any]]:
        raise NotImplementedError("Batch generation requires working get_patch().")

    def save_batch(self, patches: List[Dict[str, Any]], output_dir: Path) -> List[Path]:
        saved_paths = []
        for patch in patches:
            x, z = patch["x"], patch["z"]
            output_path = self.get_patch_filename(x, z, output_dir)
            saved_path = self.save_patch_npz(patch, output_path)
            saved_paths.append(saved_path)
        logger.info(f"Saved batch of {len(saved_paths)} patches to {output_dir}")
        return saved_paths
